(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{510:function(e,t,o){"use strict";o.r(t);var n=o(2),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("p",[e._v("Read Frontend Frameworks with Vue3 > Understanding VueJs Lifecycle Hooks and answer the following questions")]),e._v(" "),o("p",[e._v("What are lifecycle hooks? What are lifecycle hooks used for?")]),e._v(" "),o("p",[e._v("Hooks allow the developer to see what is happening behind the scenes as code is read. Hooks let us know when events are happening, such as: beforeCreated then created, before mounted and mounted, updates and beforeDestroy.")]),e._v(" "),o("p",[e._v("How have you utilized lifecycle hooks in your afternoon projects?")]),e._v(" "),o("p",[e._v("In all honesty, I do not believe I have. onMount() is the only hook I have used and Iâ€™m not completely sure that it's a hook. I completely see the benefit in using hooks and will commit to implementing them in the future.")]),e._v(" "),o("p",[e._v("What are mounting hooks? When might you use them?")]),e._v(" "),o("p",[e._v("Before Mount hooks run right before the initial render and after the template or functions have compiled. Mounted hooks give full access to the reactive component, templates, and DOM. You would use the MOUNTED for modifying the DOM.")]),e._v(" "),o("p",[e._v("https://amgorder.github.io/latewinter21-gregslist/")])])}),[],!1,null,null,null);t.default=s.exports}}]);